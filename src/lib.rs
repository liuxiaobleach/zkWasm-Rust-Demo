use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    rlp()
}

// pub fn rlp() -> i64 {
//     let data = [200, 131, 97, 98, 99, 131, 100, 101, 102];
//     let animal: String = rlp::decode(&data).expect("could not decode");
//     println!("{:?}", animal);
//     assert_eq!(animal, "cat".to_owned());
//     0
// }

pub fn rlp() -> i64 {
    let data: Vec<u8> = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
    println!("{:?}", data);
    let res: String = rlp::decode(&data).unwrap();
    // assert_eq!(_animal, "cat".to_owned());
    println!("{:?}", res);
    0
}

// pub fn rlp_encode() {
//     let data = ["abc", "d"];
//     let res:Vec<u8> = rlp::encode_list::<E, &str>(&data).to_vec();
//     println!("{:?}", res);
// }

pub fn rlp_list(data: Vec<u8>) -> i64 {
    // let data= vec![248, 88, 179, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 163, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
    // let data = vec![248, 94, 131, 97, 98, 99, 248, 88, 179, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 163, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
    // let data = vec![0xc3, 0x82,0x53,0x51];
    // let data = vec![0xc5,0x12,0x18,0xc2,0x12,0x18];
    println!("{:?}", data);
    let res: String = rlp::decode(&data).unwrap();
    // assert_eq!(_animal, "cat".to_owned());
    println!("{:?}", res);
    0
}

pub enum DataType {
    STRING,
    LIST
}

pub fn decode_length(input: &[u8]) -> Result<(usize, usize, DataType), &str> {
    let length = input.len();
    if length == 0 {
        Err("input is null")
    } else {
        let prefix = usize::from( input[0]);
        if prefix <= 0x7f {
            Ok((0, 1, DataType::STRING))
        } else if prefix <= 0xb7 && length > (prefix - 0x80) {
            Ok((0, prefix - 0x80, DataType::STRING))
        } else {
            Err("input does not conform to RLP encoding form")
        }
    }
}

pub fn to_integer(b: &[u8]) -> Result<usize, &str> {
    let length = b.len();
    if length == 0 {
        decode

        Err("input is null")
    } else if length == 1 {
        Ok(usize::from(b[0]))
    } else {
        Ok(usize::from(b[length-1]) + to_integer(&b[0..length-1]).unwrap() * 256)
    }
}

/*pub fn _decode(input: &[u8]) -> ([u8], &[u8]) {
    let mut len: u8;
    let mut llen: u8;
    let mut d: (&[u8], &[u8]);
    let mut decoded: Vec<[u8]>;
    let mut pre_byte: u8 = input[0];

    if pre_byte <= 0x7f { // <= 127 single byte
        res = input[0..1];
        remainder = &input[1..];
        ( res, remainder )  
    } else if pre_byte <= 0xb7 { 
        // <= 183 string(0-55)
        len = pre_byte - 0x7f;
        res = &input[1..len as usize];
        remainder = &input[len as usize..];
        ( res, remainder )  
    } else if pre_byte <= 0xbf { 
        // <=191, string over 55
        llen = pre_byte - 0xb7;
        len = decodeLength(&input[1..llen as usize]);
        res = &input[llen as usize..llen as usize + len as usize];
        remainder = &input[len as usize + llen as usize..];
        ( res, remainder ) 
    } else if pre_byte <= 0xf7 { 
        // <=247 list
        len = pre_byte - 0xc0; // -192 
        while remainder.len() > 0 {
           let (d_res, d_remainder) = _decode(remainder);
            Vec::push(&mut decoded, d_res);
           remainder = d_remainder;
        }
        (decoded, &input[len as usize..])
    } else {
        // a list  over 55 bytes long
        llen = pre_byte - 0xf6;
        len = decodeLength(&input[1..llen as usize]);
        let total_len = len + llen;
        remainder = &input[llen as usize..total_len as usize];

        while remainder.len() > 0 {
            let (d_res, d_remainder) = _decode(remainder);
            decoded.push(d_res);
            remainder = d_remainder;
        }

        (decoded, &input[total_len as usize..])
    }
}*/

#[cfg(test)]
mod tests {
    use crate::_decode;

    #[test]
    fn test_rlp() {
        //let data = vec![184, 86, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
        // let data = vec![185, 4, 0, 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97,97, 97, 97,97,97, 97, 97];
        // rlp_list(data);
        // let data = vec![0xc3, 0x82,0x53,0x51];
        // let data: Vec<u8> = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
        //let (res, remainder) = _decode(&data);
        //println!("kkkkkk: {:?}", res);
    }
}

// ["abc", "def"] => [200, 131, 97, 98, 99, 131, 100, 101, 102]
// pub fn toBytes(x: String) -> Vec<u8> {  
    
//     let my_bytes = x.as_bytes().to_vec();
//     my_bytes
// }

// pub fn isHexPrefixed(x: String) -> bool {
//     &x[0..2]
// }

// pub fn hexToBytes(x: String) -> Vec<u8> {
//     let my_bytes = x.as_bytes().to_vec();
//     my_bytes
// }


    // let data = vec![131, 100, 111, 103];
    // let data = vec![248, 88, 179, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 163, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
    // let strr = "0xf86e82012185060db88400825208945550519d3ded948884ea0337e3524c24955115d288b8fdac5fe7f500008025a01c47eb4a492ab4a0bf318e6d0ba95f7338d9c83cba3e9691b8ef025b98b84130a0355d0e6031059772febe31516068018280cebcbdfe21abf341189909e07dd3fd";
    // let data = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
    // let data = [207, 137, 99, 111, 100, 101, 98, 97, 111, 107, 117, 132, 109, 97, 108, 101];
    // let animal: String = rlp::decode(&data).expect_throw("error");