// ["abc", "def"] => [200, 131, 97, 98, 99, 131, 100, 101, 102]
// pub fn toBytes(x: String) -> Vec<u8> {  
    
//     let my_bytes = x.as_bytes().to_vec();
//     my_bytes
// }

// pub fn isHexPrefixed(x: String) -> bool {
//     &x[0..2]
// }

// pub fn hexToBytes(x: String) -> Vec<u8> {
//     let my_bytes = x.as_bytes().to_vec();
//     my_bytes
// }


    // let data = vec![131, 100, 111, 103];
    // let data = vec![248, 88, 179, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 163, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
    // let strr = "0xf86e82012185060db88400825208945550519d3ded948884ea0337e3524c24955115d288b8fdac5fe7f500008025a01c47eb4a492ab4a0bf318e6d0ba95f7338d9c83cba3e9691b8ef025b98b84130a0355d0e6031059772febe31516068018280cebcbdfe21abf341189909e07dd3fd";
    // let data = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
    // let data = [207, 137, 99, 111, 100, 101, 98, 97, 111, 107, 117, 132, 109, 97, 108, 101];
    // let animal: String = rlp::decode(&data).expect_throw("error");


 // let data = vec![185, 4, 0, 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,97, 97, 97, 97,
        // 97, 97, 97, 97,97, 97, 97, 97,97,97, 97, 97,97,97, 97, 97];


        use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    rlp()
}


pub fn rlp() -> i64 {
    let data: Vec<u8> = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
    println!("{:?}", data);
    let res: String = rlp::decode(&data).unwrap();
    // assert_eq!(_animal, "cat".to_owned());
    println!("{:?}", res);
    0
}


pub fn rlp_list(data: Vec<u8>) -> i64 {
    println!("{:?}", data);
    let res: String = rlp::decode(&data).unwrap();
    // assert_eq!(_animal, "cat".to_owned());
    println!("{:?}", res);
    0
}

pub enum DataType {
    STRING,
    LIST,
}

pub fn _decode(input: Vec<u8>) {
  let mut out_put: &[u8];
  // let a: Vec<u8> = Vec::from([1,2,3,4,5,6]);
  // let mut t: &[u8] = &a[1..3];
  // t.push([1,2,3]);
  // let m: Vec<Vec<u8>> = Vec::from([a]);

  let list_out: Vec<&[u8]>;
  let res = decode_length(&input);
  match res {
    Ok((offset, len, ty)) => {
      match ty {
        DataType::STRING => {
          out_put = &input[offset..len];
        },
        DataType::LIST => {

        }
      }
    },
    Err(e) => {
      println!("error decode length: {:?}", e);
    },
  }
}

pub fn decode_length(input: &[u8]) -> Result<(usize, usize, DataType), &str> {
  let length = input.len();
  if length == 0 {
      Err("input is null")
  } else {
      let prefix = usize::from( input[0]);
      if prefix <= 0x7f {
          Ok((0, 1, DataType::STRING))
      } else if prefix <= 0xb7 && length > (prefix - 0x80) {
          Ok((0, prefix - 0x80, DataType::STRING))
      } else {
          Err("input does not conform to RLP encoding form")
      }
  }
}

#[cfg(test)]
mod tests {
    use crate::_decode;

    #[test]
    fn test_rlp() {
        let data = vec![184, 86, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
        _decode(data);
    }
}



use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    rlp()
}

// pub fn rlp() -> i64 {
//     let data = [200, 131, 97, 98, 99, 131, 100, 101, 102];
//     let animal: String = rlp::decode(&data).expect("could not decode");
//     println!("{:?}", animal);
//     assert_eq!(animal, "cat".to_owned());
//     0
// }

pub fn rlp() -> i64 {
    let data: Vec<u8> = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
    println!("{:?}", data);
    let res: String = rlp::decode(&data).unwrap();
    // assert_eq!(_animal, "cat".to_owned());
    println!("{:?}", res);
    0
}

// pub fn rlp_encode() {
//     let data = ["abc", "d"];
//     let res:Vec<u8> = rlp::encode_list::<E, &str>(&data).to_vec();
//     println!("{:?}", res);
// }

pub fn rlp_list(data: Vec<u8>) -> i64 {
    // let data= vec![248, 88, 179, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 163, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
    // let data = vec![248, 94, 131, 97, 98, 99, 248, 88, 179, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 163, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
    // let data = vec![0xc3, 0x82,0x53,0x51];
    // let data = vec![0xc5,0x12,0x18,0xc2,0x12,0x18];
    println!("{:?}", data);
    let res: String = rlp::decode(&data).unwrap();
    // assert_eq!(_animal, "cat".to_owned());
    println!("{:?}", res);
    0
}

pub fn decodeLength(len: &[u8]) -> u8 {
    // let hex: String;
    // for i in len.iter() {
    //     println!("hex: {:?} ", i);  
    // }
    86
}



pub fn _decode(input: &[u8]) -> (&[u8], Vec<&[u8]>, &[u8]) {
    let len: usize; 
    let llen: usize;
    let mut str_out: &[u8] = &[];
    let mut list_out: Vec<&[u8]> = Vec::new();

    let mut remainder: &[u8];
    let pre_byte: u8 = input[0];
    if pre_byte <= 0x7f { // <= 127 single byte
        str_out = &input[0..1];
        remainder = &input[1..];
        (str_out, list_out, remainder)  
    } else if pre_byte <= 0xb7 { 
        // <= 183 string(0-55)
        len = usize::from(pre_byte) - 127;
        if pre_byte == 0x80 {
            str_out = &[];
        } else {
            if len <= input.len() {
                str_out = &input[1..len];
            } else {
                str_out = &input[1..];
            }
        }
        remainder = &input[len..];
        (str_out, list_out, remainder )  
    } else if pre_byte <= 0xbf { 
        // <=191, string over 55
        llen = usize::from(pre_byte) - 0xb6;
        let len_res = to_integer(&input[1..llen]);
        match len_res {
            Ok(l) => len = l,
            Err(error) => {
                panic!("Problem to integer: {:?}", error)
            },
        }
        str_out = &input[llen..llen + len];
        remainder = &input[len + llen..];
        (str_out, list_out, remainder ) 
    } else if pre_byte <= 0xf7 { 
        // <=247 list
        len = usize::from(pre_byte) - 0xbf; // -192 
        remainder = &input[1..len];
        while remainder.len() > 0 {
          let (d_str, d_list, d_remainder) = _decode(remainder);
          if d_str.len() > 0 {
            list_out.push(d_str);
          }

        if d_list.len() > 0 {
            list_out.push(&[]);
            list_out.append(&mut d_list.clone());
        }
          remainder = d_remainder;
        }
        (str_out, list_out, remainder ) 
    } else {
        // a list over 55 bytes long
        llen = usize::from(pre_byte) - 0xf6;
        // len = to_integer(&input[1..llen as usize]);
        let len_res = to_integer(&input[1..llen]);
        match len_res {
            Ok(l) => len = l,
            Err(error) => {
                panic!("Problem to integer: {:?}", error)
            },
        }
        let total_len = len + llen;
        remainder = &input[llen..total_len];

        while remainder.len() > 0 {
            let (d_str, d_list, d_remainder) = _decode(remainder);
            if d_str.len() > 0 {
              list_out.push(d_str);
            }
            if d_list.len() > 0 {
                list_out.push(&[]);
                list_out.append(&mut d_list.clone());
            }
            remainder = d_remainder;
        }
        (str_out, list_out, remainder) 
    }
}


pub fn to_integer(b: &[u8]) -> Result<usize, &str> {
    let length = b.len();
    if length == 0 {
        Err("input is null")
    } else if length == 1 {
        Ok(usize::from(b[0]))
    } else {
        Ok(usize::from(b[length-1]) + to_integer(&b[0..length-1]).unwrap() * 256)
    }
}

pub fn rlp_arr(list: Vec<&[u8]>) {
    // [[1], [147, 131, 3], [0, 1], [], [198], [145, 33], [], [72], [127, 173]]

    // [[1], [147, 131, 3], [0, 1], [[198], [145, 33], [[72], [127, 173]]]]
    //["0x01", "0x938303", "0x01", ["0xc6", "0x9121"], ["0x48", "0x7fad"]]
    let res: Vec<&[u8]>;
    // for i in list.iter() {
    //     if i == &[] {
    //         println!("[]");
    //     } else {
    //         res.push();
    //     }  
    // }
}

// 0xd80183938303820001ca81c6829121c448827fad8393830301
// ["0x01","0x938303","0x0001",["0xc6","0x9121",["0x48","0x7fad"]], "0x938303", "0x01"]

#[cfg(test)]
mod tests {
    use crate::_decode;

    #[test]
    fn test_rlp() {
        // let data = vec![184, 86, 84, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 105, 115, 32, 115, 101, 110, 116, 101, 110, 99, 101, 32, 105, 115, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 53, 53, 32, 98, 121, 116, 101, 115, 44, 32, 73, 32, 107, 110, 111, 119, 32, 105, 116, 32, 98, 101, 99, 97, 117, 115, 101, 32, 73, 32, 112, 114, 101, 45, 100, 101, 115, 105, 103, 110, 101, 100, 32, 105, 116];
        // rlp_list(data);
        // let data = vec![0xc3, 0x82,0x53,0x51];
        // let data: Vec<u8> = vec![200, 131, 97, 98, 99, 131, 100, 101, 102];
        // let data = [131, 97, 98, 99];
        // let data = [248,110,130,1,33,133,6,13,184,132,0,130,82,8,148,85,80,81,157,61,237,148,136,132,234,3,55,227,82,76,36,149,81,21,210,136,184,253,172,95,231,245,0,0,128,37,160,28,71,235,74,73,42,180,160,191,49,142,109,11,169,95,115,56,217,200,60,186,62,150,145,184,239,2,91,152,184,65,48,160,53,93,14,96,49,5,151,114,254,190,49,81,96,104,1,130,128,206,188,189,254,33,171,243,65,24,153,9,224,125,211,253];
        // let data = [249,4,223,1,131,147,131,3,185,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,2,1,0,0,8,0,32,0,0,0,0,0,0,8,0,0,0,0,0,8,0,0,0,8,8,0,0,8,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,16,0,8,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,32,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,32,0,0,0,8,0,0,0,0,0,2,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,32,0,0,0,0,0,0,0,16,0,0,0,0,0,4,0,16,0,0,0,0,0,0,0,0,0,0,0,4,0,249,3,212,248,253,148,0,0,0,0,0,34,212,115,3,15,17,109,222,233,246,180,58,199,139,163,248,132,160,198,163,119,191,196,235,18,0,36,168,172,8,238,242,5,190,22,184,23,2,8,18,199,50,35,232,29,27,219,151,8,236,160,0,0,0,0,0,0,0,0,0,0,0,0,245,233,213,80,195,197,3,100,214,48,237,180,117,59,228,4,205,16,145,33,160,0,0,0,0,0,0,0,0,0,0,0,0,160,184,105,145,198,33,139,54,193,209,157,74,46,158,176,206,54,6,235,72,160,0,0,0,0,0,0,0,0,0,0,0,0,63,201,26,58,253,112,57,92,212,150,198,71,213,166,204,157,75,43,127,173,184,96,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,214,65,206,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,155,148,192,42,170,57,178,35,254,141,10,14,92,79,39,234,217,8,60,117,108,194,248,99,160,221,242,82,173,27,226,200,155,105,194,176,104,252,55,141,170,149,43,167,241,99,196,161,22,40,245,90,77,245,35,179,239,160,0,0,0,0,0,0,0,0,0,0,0,0,136,230,160,194,221,210,111,238,182,79,3,154,44,65,41,111,203,63,86,64,160,0,0,0,0,0,0,0,0,0,0,0,0,63,201,26,58,253,112,57,92,212,150,198,71,213,166,204,157,75,43,127,173,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,84,66,237,153,70,225,209,248,155,148,160,184,105,145,198,33,139,54,193,209,157,74,46,158,176,206,54,6,235,72,248,99,160,221,242,82,173,27,226,200,155,105,194,176,104,252,55,141,170,149,43,167,241,99,196,161,22,40,245,90,77,245,35,179,239,160,0,0,0,0,0,0,0,0,0,0,0,0,245,233,213,80,195,197,3,100,214,48,237,180,117,59,228,4,205,16,145,33,160,0,0,0,0,0,0,0,0,0,0,0,0,136,230,160,194,221,210,111,238,182,79,3,154,44,65,41,111,203,63,86,64,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,154,202,0,249,1,28,148,136,230,160,194,221,210,111,238,182,79,3,154,44,65,41,111,203,63,86,64,248,99,160,196,32,121,249,74,99,80,215,230,35,95,41,23,73,36,249,40,204,42,200,24,235,100,254,216,0,78,17,95,188,202,103,160,0,0,0,0,0,0,0,0,0,0,0,0,63,201,26,58,253,112,57,92,212,150,198,71,213,166,204,157,75,43,127,173,160,0,0,0,0,0,0,0,0,0,0,0,0,63,201,26,58,253,112,57,92,212,150,198,71,213,166,204,157,75,43,127,173,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,154,202,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,248,171,189,18,102,185,30,47,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,89,202,157,112,255,119,47,253,132,4,101,163,133,156,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,202,88,234,188,212,72,118,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,16,159,248,122,148,192,42,170,57,178,35,254,141,10,14,92,79,39,234,217,8,60,117,108,194,248,66,160,127,207,83,44,21,240,166,219,11,214,208,224,56,190,167,29,48,216,8,199,217,140,179,191,114,104,169,91,245,8,27,101,160,0,0,0,0,0,0,0,0,0,0,0,0,63,201,26,58,253,112,57,92,212,150,198,71,213,166,204,157,75,43,127,173,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,84,66,237,153,70,225,209];
        // let data = [211,1,131,147,131,3,130,0,1,202,129,198,130,145,33,196,72,130,127,173];
        let data = [216,1,131,147,131,3,130,0,1,202,129,198,130,145,33,196,72,130,127,173,131,147,131,3,1];
        let (str, list, remainder) = _decode(&data);
        println!("str: {:?}", str);
        println!("list: {:?}", list);
        println!("remainder: {:?}", remainder);
    }
}


